shaderSource[document.currentScript.src.split('js/shaders/')[1]] = `
  precision highp float;

  uniform sampler2D colorTexture;
  uniform mat4 textureProjMatrix;
  uniform float uAlpha;
  uniform vec3 uCameraPos;

  uniform mat4 rotateMat;

  // Light
  uniform vec4 lightPos[10]; // xyz is the direction, w is 0
  uniform vec4 lightPowerDensity[10]; // w ignored
  uniform vec3 uAmbientLight;
  uniform vec3 uMaterialShinyColor;
  uniform highp float uShinyFactor;
  uniform float uRenderAsShadow;

  varying vec2 texCoord;
  varying vec3 worldPos;
  varying vec3 worldNormal;

  float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
  }

  float noise(vec2 n) {
    const vec2 d = vec2(0.0, 1.0);
    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));
    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
  }

  float modI(float a,float b) {
      float m=a-floor((a+0.5)/b)*b;
      return floor(m+0.5);
  }

  vec3 woodGrain(vec3 p) {
    float radius = length(p.xz) * 30.0 + noise(p.xz);
    float angle;

    if(p.x == 0.0) {
      angle = 3.14159/2.0;
    } else {
      angle = atan(p.z/p.x);
    }

    //perturb the radius by an amount based on angle and height
    radius = radius + (2.0 * sin(20.0 * angle + noise(p.yz) / 150.0) ) ;

    //map radius into the range (0..59)
    float grain = modI(radius, 60.0);

    // choose light grain 2/3 of the time, dark grain 1/3
    if (grain < 40.0) {
      return vec3(204.0/255.0, 153.0/255.0, 0.0);
    } else {
      return vec3(153.0/255.0, 102.0/255.0, 51.0/255.0);
    }
  }

  void main(void) {

    vec3 diffuseComponent;
    vec3 shinyComponent;
    vec3 viewDir = normalize(uCameraPos - worldPos);
    vec3 normalizedWorldNormal = normalize(worldNormal);

    for(int i = 0; i < 10; i++) {
      vec3 lightDirection = lightPos[i].xyz - (worldPos * lightPos[i].w);

      highp float powerMagnitude = 1.0 / dot(lightDirection, lightDirection);
      vec3 powerMag = lightPowerDensity[i].xyz * powerMagnitude;

      highp float directionalComponent = max(dot(normalize(lightDirection), normalizedWorldNormal), 0.0);
      diffuseComponent += powerMag * directionalComponent;

      vec3 halfway = normalize(viewDir + normalize(lightDirection));
      shinyComponent += powerMag * uMaterialShinyColor * pow(max(dot(normalizedWorldNormal, halfway), 0.0), uShinyFactor);
    }

    //highp float procedural_g = (1.0 + sin((worldPos.x + noise(vec2(worldPos.x * 5.0, worldPos.z * 5.0)) / 2.0) * 50.0)) / 2.0;
    highp float procedural_g = (1.0 + sin((worldPos.x + noise(vec2(worldPos.x * 2.0, worldPos.z * 2.0)) / 1.3) * 10.0)) / 2.0;
    gl_FragColor = vec4(vec3(procedural_g * 0.8, procedural_g * 0.8, procedural_g * 1.2) * (uAmbientLight + diffuseComponent) + shinyComponent, 1.0);
  }
`;
