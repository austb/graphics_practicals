shaderSource[document.currentScript.src.split('js/shaders/')[1]] = `
  precision highp float;

  uniform sampler2D grassTexture;
  uniform sampler2D probeTexture;
  uniform float uAlpha;
  uniform vec3 uCameraPos;

  uniform mat4 rotateMat;

  // Light
  uniform vec4 lightPos[10]; // xyz is the direction, w is 0
  uniform vec4 lightPowerDensity[10]; // w ignored
  uniform vec3 uAmbientLight;
  uniform vec3 uMaterialShinyColor;
  uniform highp float uShinyFactor;
  uniform float uRenderAsShadow;

  varying vec2 texCoord;
  varying vec3 worldPos;
  varying vec3 worldNormal;

  varying vec3 rayDir;
  varying vec3 screenPos;

  float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
  }

  float noise(vec2 n) {
    const vec2 d = vec2(0.0, 1.0);
    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));
    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
  }

  vec2 noisify(vec2 v) {
    float xcoord = v.x;
    float zcoord = v.y;
    return vec2(xcoord + sin(zcoord), zcoord);
  }

  void main(void) {

    vec3 rayDirection = normalize(rayDir);
    highp float t = -uCameraPos.y / rayDirection.y;

    if(t <= 0.0) {
      //find corresponding point in light probe
      vec2 probeTex = (normalize(vec3(0, 0, 1) + normalize(rayDirection)).xy / vec2(2, -2)) + vec2(0.5, 0.5);
      gl_FragColor = vec4(screenPos, 1.0);
      gl_FragColor = texture2D(probeTexture, probeTex);
    } else {
      vec3 ray = uCameraPos + rayDirection * t;
      vec2 noiseVec = noisify(rayDirection.xz);

      vec3 diffuseComponent;
      vec3 shinyComponent;
      vec3 viewDir = normalize(uCameraPos - worldPos);
      vec3 normalizedWorldNormal = normalize(worldNormal);

      for(int i = 0; i < 10; i++) {
        vec3 lightDirection = lightPos[i].xyz - (worldPos * lightPos[i].w);

        highp float powerMagnitude = 1.0 / dot(lightDirection, lightDirection);
        vec3 powerMag = lightPowerDensity[i].xyz * powerMagnitude;

        highp float directionalComponent = max(dot(normalize(lightDirection), normalizedWorldNormal), 0.0);
        diffuseComponent += powerMag * directionalComponent;

        vec3 halfway = normalize(viewDir + normalize(lightDirection));
        shinyComponent += powerMag * uMaterialShinyColor * pow(max(dot(normalizedWorldNormal, halfway), 0.0), uShinyFactor);
      }

      vec4 tex = texture2D(grassTexture, noiseVec);
      gl_FragColor = vec4( tex.rgb * (uAmbientLight + diffuseComponent) + shinyComponent, tex.a);

      highp float procedural_g = (1.0 + sin((noiseVec.x + noise(noiseVec) / 90.0) * 100.0)) / 2.0;
      gl_FragColor = vec4(vec3(procedural_g * 0.8, procedural_g * 0.8, procedural_g * 1.2) * (uAmbientLight + diffuseComponent) + shinyComponent, 1.0);
    }
  }
`;
