shaderSource[document.currentScript.src.split('js/shaders/')[1]] = `
  precision highp float;

  uniform sampler2D probeTexture;
  uniform mat4 textureProjMatrix;
  uniform float uAlpha;
  uniform vec3 uAmbientLight;
  uniform vec3 uCameraPos;
  uniform float uProceduralNormal;

  // Light
  uniform vec4 lightPos[10]; // xyz is the direction, w is 0
  uniform vec4 lightPowerDensity[10]; // w ignored

  varying vec2 texCoord;
  varying vec3 worldPos;
  varying vec3 worldNormal;
  varying vec3 rayDir;
  varying vec3 screenPos;

  float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
  }

  float noise(vec2 n) {
    const vec2 d = vec2(0.0, 1.0);
    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));
    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
  }

  void main(void) {

    vec3 viewDir = normalize(uCameraPos - worldPos);
    vec3 normalizedWorldNormal;
    if(uProceduralNormal == 1.0) {
      normalizedWorldNormal = normalize(worldNormal - vec3(noise(vec2(worldPos.y, worldPos.y)), 0.0, 0.0));
    } else {
      normalizedWorldNormal = normalize(worldNormal);
    }

    // compute ideal reflected direction 
    vec3 reflDir = reflect(-viewDir, normalizedWorldNormal);

    //find corresponding point in light probe
    vec2 probeTex = (normalize(vec3(0, 0, 1) + reflDir).xy / vec2(2, -2)) + vec2(0.5, 0.5);
    //gl_FragColor = vec4(reflDir, 1);
    gl_FragColor = texture2D( probeTexture, probeTex);
  }
`;
